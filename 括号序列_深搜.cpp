
/* run this program using the console pauser or add your own getch,、、
给定一个括号序列，要求尽可能少地添加若干括号使得括号序列变得合法，当添加完成后，会产生不同的添加结果，请问有多少种本质不同的添加结果。

两个结果是本质不同的是指存在某个位置一个结果是左括号，而另一个是右括号。
	(((()) 
例如，对于括号序列 ((()，只需要添加两个括号就能让其合法，有以下几种不同的添加结果：
()()()  ()(())  (()) ()  (()())  ((( )))
输入描述 
输入一行包含一个字符串 s，表示给定的括号序列，序列中只有左括号和右括号。

输出描述
输出一个整数表示答案，答案可能很大，请输出答案除以 10000000071000000007 
(即 10^9 + 7)10 
9
 +7) 的余数。
*/


#include <iostream>
#include <cstring>
#include <algorithm>
#include <set>
using namespace std;

int n;
string s;
set<string> ret;
//此时的左括号数 右括号数 添加的左括号数 右括号数 当前位置 当前序列   
void dfs(int l,int r,int al,int ar,int idx,string cur){
    if(idx==n){
        if(!al&&!ar)
            ret.insert(cur);
        return;
    }
    if(al)//要补的左括号数    ((()
        dfs(l+1,r,al-1,ar,idx,cur+'(');
    if(ar&&l>r) // 要补的右括号数 并且此时的左括号数大于右括号数才补右括号数  
        dfs(l,r+1,al,ar-1,idx,cur+')');
    if(s[idx]=='(')
        dfs(l+1,r,al,ar,idx+1,cur+'(');
    else if(l>r) // 补右括号数  
        dfs(l,r+1,al,ar,idx+1,cur+')');
}

int main(){
    cin>>s;
    n=s.size();
    int al=0,ar=0,l=0;
    for(int i=0;i<s.length();++i){
        if(s[i]=='('){  //((()  ()))
            l++;
        }
        else if(s[i]==')'){
            if(l==0)
                al++; //要补的左括号数  
            else{
                l--;
            }
        }
    }
    ar=l; 
    dfs(0,0,al,ar,0,"");
    cout<<ret.size()<<endl;
    
    for(set<string>::iterator it=ret.begin();it!=ret.end();it++){
		cout << *it << endl;
	}
    
    
}



/*

用一个常用的括号序列模型来讲，当前在 (x,y)，读到左括号就走到(x+1,y+1)，
读到右括号就走到(x+1,y-1)，合法的括号序列是 (0,0) 走到 (2n,0)，路
径不经过 y=-1，即对于每个 x_i，对应有 y_i>=0。类似地，定义括号路径。
最少添加多少括号可以得到合法括号序列？每次走到 y=-1 时，在前面向上走一次；
最终如果 y!=0，再往下走若干次到 y=0。
还有许多添加括号数量相同的其他方案。任取其一，
考虑原括号序列的某两个括号间被添加的新括号（如果有本质相同的添加方案，任取其一）。
添加的新括号一定形如 )))((((，即不可能存在 ()，即方案不同仅当添加的左右括号数量不同，
与相对位置无关。所以，添加的左右括号可以分别计数，答案相乘，接下来会具体解释。
以仅考虑添加左括号为例。从一条合法括号路径中删除被添加的右括号，
得到的新路径等价于在原路径的每个向下走之前，添加若干个向上走，且这条新路径也不经过 
y=-1，这可以用 DP 在 O(n^2) 做。类似地，可以得到从一条合法括号路径中删除被添加的
左括号的路径。这两类路径是可以任意合并成合法括号路径的，任意合法括号路径也可以分解为
这两类路径。
――――――――――――――――
版权声明：本文为CSDN博主「Ghcred」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Ghcred/article/details/116066941

*/ 

/*

*/
























